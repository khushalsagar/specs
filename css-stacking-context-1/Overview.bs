<pre class='metadata'>
Title: CSS Stacking Context Module Level 1
Shortname: css-stacking-context
Level: 1
Status: UD
Group: csswg
ED: https://drafts.csswg.org/css-stacking-context/
Work Status: exploring
Editor: Tab Atkins-Bittner, Google, http://xanthir.com/contact/, w3cid 42199
Abstract: This module defines the painting model for CSS.
</pre>

<style>
/* Put nice boxes around each algorithm. */
[data-algorithm]:not(.heading) {
  padding: .5em;
  border: thin solid #ddd; border-radius: .5em;
  margin: .5em calc(-0.5em - 1px);
}
[data-algorithm]:not(.heading) > :first-child {
  margin-top: 0;
}
[data-algorithm]:not(.heading) > :last-child {
  margin-bottom: 0;
}
[data-algorithm] [data-algorithm] {
    margin: 1em 0;
}
</style>

<pre class=link-defaults>
spec: css-backgrounds-3; type:dfn;
	text: background painting area
	text: background positioning area
</pre>

Introduction {#intro}
=====================

	<em>This section is not normative.</em>

	Elements on a page can have many overlapping parts.
	This specification defines the precise order
	that every part of an element
	and the surrounding page
	is painted,
	so that things render above (or below) other things
	in a well-defined way.

Painting Order {#order}
=======================

	The rendering structure of a document consists of
	a [=root canvas=],
	a [=document layer=]
	and any number of additional [=rendering layers=],
	and within each layer,
	a [=/list=] of one or more [=trees=] of [=CSS/boxes=] generated by [=CSS/elements=].

	A <dfn for=CSS export>canvas</dfn> is a theoretically-infinite 2D field of color.
	The <dfn for=CSS export>root canvas</dfn> is the [=CSS/canvas=]
	upon which all of the document's content is rendered.
	Layers, and elements that generate stacking contexts,
	first render onto temporary [=CSS/canvases=]
	before being composited onto an ancestor canvas
	(ending with the [=root canvas=] for the document).

	A <dfn for=CSS export local-lt="layer">rendering layer</dfn>
	is an ordered list of [=boxes=],
	where each layer is rendered fully atop all previous layers,
	and fully below all following layers.
	Within the layer,
	[=boxes=] and their descendants
	can potentially interweave their rendering with each other.
	The <dfn>document layer</dfn> is the layer
	containing the principal box of the document's root element;
	it is below all other [=rendering layers=].

	<div algorithm>
		To <dfn export lt="paint a document|paint the document">paint a document</dfn>:

		1. If the document is being painted as part of another document
			(such as an <{iframe}>'s document),
			then the [=root canvas=] is initially [=transparent black=] everywhere.

			Otherwise, the [=root canvas=] is a UA-defined color everywhere.
			This can be affected by things such as, but not limited to,
			the 'color-scheme' property.

			Other specifications can define that the [=root canvas=]
			begins as another color in certain circumstances.

		2. [=paint a layer|Paint the document layer=] onto the [=root canvas=].

		3. For each additional [=rendering layer=], in order from bottom to top,
			[=paint the layer=] onto the [=root canvas=].
	</div>

	<div algorithm="paint a layer">
		To <dfn export lt="paint a layer|paint the layer">paint a layer</dfn> |layer| onto a |root canvas|:

		1. Let |canvas| be a fresh [=CSS/canvas=].
			initially [=transparent black=] everywhere.

		2. If |layer| is the [=document layer=],
			and the root element generates a [=box=],
			then the root element <dfn export lt="propagate its background">propagates its background</dfn>
			to |canvas|:
			the root element's 'background' is painted onto |canvas|,
			using all of |canvas| as the [=background painting area=],
			but continuing to use the root element
			to determine the [=background positioning area=].

			Issue: [[CSS-CONTAIN-3]] should, apparently, block propagation,
			but I can't find that in the spec.
			Figure out if I missed something,
			and make it block propagation here.

		3. For each top-level [=box=] in |layer|,
			[=paint a stacking context=] of the box onto |canvas|.

		4. Issue: Clipping/filtering/etc goes here.

		5. Composite |canvas| onto |root canvas|.

			Issue: Does only the document layer have non-trivial whole-layer compositing?
	</div>

	<div algorithm>
		To <dfn export lt="paint a stacking context|paint the stacking context">paint a stacking context</dfn> with a [=box=] |box| onto a [=CSS/canvas=] |root canvas|:

		1. Let |canvas| be a fresh [=CSS/canvas=],
			initially [=transparent black=] everywhere.

		2.
			<dl class=switch>
				: If |box| is a [=block-level=] box other than a [=table wrapper box=]
				::
					If |box| did <em>not</em> [=propagate its background=],
					paint |box|’s background color onto |canvas|,
					then background image.

					In all cases,
					then paint |box|’s border onto |canvas|.

				: If |box| if a [=block-level=] [=table wrapper box=]:
				:: Paint the following onto |canvas|, in order:

					1. If |box| did <em>not</em> [=propagate its background=],
						paint |box|’s backgrounds
						(color, then image)
						onto |canvas|.

					2. Paint |box|’s column group’s backgrounds
						(color, then image)
						onto |canvas|.

					3. Paint |box|’s column’s backgrounds
						(color, then image)
						onto |canvas|.

					4. Paint |box|’s row group’s backgrounds
						(color, then image)
						onto |canvas|.

					5. Paint |box|’s row’s backgrounds
						(color, then image)
						onto |canvas|.

					6. Paint |box|’s cell’s backgrounds
						(color, then image)
						onto |canvas|.

					7. Paint all of |box|’s table borders
						(in tree order, for separated borders)
						onto |canvas|.

						Issue: I think this needs more detail,
						and I think [[CSS-TABLES-3]] provides it.
			</dl>

		3. For each [=stacking context=] descendant of |box|
			with strictly negative z-indexes,
			in z-index order
			(most negative first),
			then tree order,
			[=paint a stacking context=] for the descendant
			onto |canvas|.

		4. For each in-flow,
			non-[=positioned=],
			[=block-level=]
			descendant of |box|,
			in tree order:

			<dl class=switch>
				: If the descendant is not a [=table wrapper box=]
				:: Paint its background color,
					then background image,
					then border
					onto |canvas|.

				: If the descendant is a [=table wrapper box=]
				::
					1. Paint its backgrounds
						(color, then image)
						onto |canvas|.

					2. Paint its column group’s backgrounds
						(color, then image)
						onto |canvas|.

					3. Paint its column’s backgrounds
						(color, then image)
						onto |canvas|.

					4. Paint its row group’s backgrounds
						(color, then image)
						onto |canvas|.

					5. Paint its row’s backgrounds
						(color, then image)
						onto |canvas|.

					6. Paint its cell’s backgrounds
						(color, then image)
						onto |canvas|.

					7. Paint all of |box|’s table borders
						(in tree order, for separated borders)
						onto |canvas|.
			</dl>

		5. For each non-positioned,
			floating
			descendant of |box|:

			1.
	</div>


      <li>
	All non-positioned floating descendants, in tree order. For
	each one of these, treat the element as if it created a new
	stacking context, but any positioned descendants and
	descendants which actually create a new stacking context
	should be considered part of the parent stacking context, not
	this new one.

      <li>
	If the element is an inline element that generates a
	stacking context, then:
	<ol>
	  <li>
	    For each line box that the element is in:
	    <ol>
	      <li>Jump to <a href="#each-box">7.2.1</a> for the
	      box(es) of the element in that line box (in tree order).
	    </ol>
	</ol>

      <li>
	Otherwise: first for the element, then for all its in-flow,
	non-positioned, block-level descendants in tree order:
	<ol>
	  <li>
	    If the element is a block-level replaced element, then:
	    the replaced content, atomically.

	  <li>
	    Otherwise, for each line box of that element:
	    <ol>
	      <li id="each-box">
		For each box that is a child of that element, in
		that line box, in tree order:
		<ol>
		  <li>
		    background color of element.
		  <li>
		    background image of element.
		  <li>
		    border of element.
		  <li>
		    For inline elements:
		    <ol>
		      <li>
			For all the element's in-flow,
			non-positioned, inline-level children that are
			in this line box, and all runs of text inside
			the element that is on this line box, in tree
			order:
			<ol>
			  <li>
			    If this is a run of text, then:
			    <ol>
			      <li>any underlining affecting the text
			      of the element, in tree order of the
			      elements applying the underlining (such
			      that the deepest element's underlining,
			      if any, is painted topmost and the root
			      element's underlining, if any, is drawn
			      bottommost).

			      <li>any overlining affecting the text of
			      the element, in tree order of the
			      elements applying the overlining (such
			      that the deepest element's overlining,
			      if any, is painted topmost and the root
			      element's overlining, if any, is drawn
			      bottommost).

			      <li>the text.

			      <li>any line-through affecting the text
			      of the element, in tree order of the
			      elements applying the line-through (such
			      that the deepest element's line-through,
			      if any, is painted topmost and the root
			      element's line-through, if any, is drawn
			      bottommost).
			    </ol>

			  <li>
			    Otherwise, jump to <a href="#each-box">7.2.1</a> for that
			    element.
			</ol>
		    </ol>

		    For inline-block and inline-table elements:
		    <ol>
		      <li>For each one of these, treat the element as
		      if it created a new stacking context, but any
		      positioned descendants and descendants which
		      actually create a new stacking context should be
		      considered part of the parent stacking context,
		      not this new one.
		    </ol>

		    For inline-level replaced elements:
		    <ol>
		      <li>the replaced content, atomically.
		    </ol>
		</ol>

		<p class="note">Some of the boxes may have been
		generated by line splitting or the Unicode
		bidirectional algorithm.

	      <li>
		Optionally, the outline of the element (see <a href="#outlines">10 below</a>).
	    </ol>

	  <li>
	    Optionally, if the element is block-level, the outline
	    of the element (see <a href="#outlines">10 below</a>).
	</ol>

      <li>
	All positioned descendants with 'z-index: auto' or
	'z-index: 0', in tree order. For those with 'z-index: auto',
	treat the element as if it created a new stacking context, but
	any positioned descendants and descendants which actually
	create a new stacking context should be considered part of the
	parent stacking context, not this new one. For those with
	'z-index: 0', treat the stacking context generated atomically.

      <li>
	Stacking contexts formed by positioned descendants with
	z-indices greater than or equal to 1 in z-index order
	(smallest first) then tree order.

      <li id="outlines">
	Finally, implementations that do not draw outlines in steps
	above must draw outlines from this stacking context at this
	stage. (It is recommended to draw outlines in this step and
	not in the steps above.)
    </ol>

    <h3 id="stacking-notes">Notes</h3>

    The background of the root element is only painted once, over
    the whole canvas.

    While the backgrounds of bidirectional inlines are painted in
    tree order, they are positioned in visual order. Since the
    positioning of inline backgrounds is unspecified in CSS&nbsp;2,
    the exact result of these two requirements is UA-defined. CSS3 may
    define this in more detail.


