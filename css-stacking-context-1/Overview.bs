<pre class='metadata'>
Title: CSS Stacking Context Module Level 1
Shortname: css-stacking-context
Level: 1
Status: UD
Group: csswg
ED: https://drafts.csswg.org/css-stacking-context/
Work Status: exploring
Editor: Tab Atkins-Bittner, Google, http://xanthir.com/contact/, w3cid 42199
Abstract: This module defines the painting model for CSS.
</pre>

Introduction {#intro}
=====================

	<em>This section is not normative.</em>

	Elements on a page can have many overlapping parts.
	This specification defines the precise order
	that every part of an element
	and the surrounding page
	is painted,
	so that things render above (or below) other things
	in a well-defined way.

Painting Order {#order}
=======================

	The rendering structure of a document consists of
	a [=canvas=],
	a base [=layer=]
	and any number of additional top layers,
	and within each layer,
	a [=/list=] of one or more [=trees=] of [=CSS/boxes=] generated by [=CSS/elements=].

	The <dfn>canvas</dfn> is a theoretically-infinite 2D field,
	upon which all of the document's content is rendered.

	<div algorithm>
		To <dfn export lt="paint a document|paint the document">paint a document</dfn>:

		1. If the document is being painted as part of another document
			(such as an <{iframe}>'s document),
			then the [=canvas=] is initially [=transparent black=] everywhere.

			If the [=base layer=] has a root color,
			the [=canvas=] is initially that color everywhere.

			Otherwise, the [=canvas=] is a UA-defined color everywhere.
			This can be affected by things such as, but not limited to,
			the 'color-scheme' property.

			Issue: Check what happens with a partially-transparent bg color, especially when mixed with 'color-scheme'.

			Issue: Check what the effect of 'mix-blend-mode' on the root element is.
			I think we defined that it blends against a transparent black
			before contributing the resulting color/image to the canvas?

		2. If the [=base layer=] has a root image,
			paint that image onto the canvas,
			within the same area/origin
			that the root image's contributing element
			would use for its background image.
			If there are more than one,
			paint them in the order they would be painted as a background image.

		2. [=paint a layer|Paint the base layer=] onto the [=canvas=].

		3. For each top layer, in order from bottom to top,
			[=paint the layer=] onto the [=canvas=].
	</div>

	<div algorithm>
		To <dfn export lt="paint a layer|paint the layer">paint a layer</dfn>:

		1. For each


    The stacking context background and most negative positioned
    stacking contexts are at the bottom of the stack, while the most
    positive positioned stacking contexts are at the top of the stack.

    The canvas is transparent if contained within another, and
    given a UA-defined color if it is not. It is infinite in extent
    and contains the root element. Initially, the viewport is anchored
    with its top left corner at the canvas origin.

    The painting order for the descendants of an element generating
    a stacking context (see the 'z-index' property) is:

    <ol class="stack">
      <li>
	If the element is a root element:
	<ol>
	  <li>background color of element over the entire canvas.

	  <li>background image of element, over the entire canvas,
	  anchored at the origin that would be used if it was painted
	  for the root element.
	</ol>

      <li>
	If the element is a block, list-item, or other block
	equivalent:
	<ol>
	  <li>background color of element unless it is the root
	  element.

	  <li>background image of element unless it is the root
	  element.

	  <li>border of element.
	</ol>

	Otherwise, if the element is a block level table:

	<ol>
	  <li>table backgrounds (color then image) unless it is the
	  root element.
	  <li>column group backgrounds (color then image).
	  <li>column backgrounds (color then image).
	  <li>row group backgrounds (color then image).
	  <li>row backgrounds (color then image).
	  <li>cell backgrounds (color then image).
	  <li>all table borders (in tree order for separated borders).
	</ol>

      <li>
	Stacking contexts formed by positioned descendants with
	negative z-indices (excluding 0) in z-index order (most
	negative first) then tree order.

      <li>
	For all its in-flow, non-positioned, block-level
	descendants in tree order: If the element is a block,
	list-item, or other block equivalent:
	<ol>
	  <li>background color of element.
	  <li>background image of element.
	  <li>border of element.
	</ol>

	Otherwise, the element is a table:
	<ol>
	  <li>table backgrounds (color then image).
	  <li>column group backgrounds (color then image).
	  <li>column backgrounds (color then image).
	  <li>row group backgrounds (color then image).
	  <li>row backgrounds (color then image).
	  <li>cell backgrounds (color then image).
	  <li>all table borders (in tree order for separated borders).
	</ol>

      <li>
	All non-positioned floating descendants, in tree order. For
	each one of these, treat the element as if it created a new
	stacking context, but any positioned descendants and
	descendants which actually create a new stacking context
	should be considered part of the parent stacking context, not
	this new one.

      <li>
	If the element is an inline element that generates a
	stacking context, then:
	<ol>
	  <li>
	    For each line box that the element is in:
	    <ol>
	      <li>Jump to <a href="#each-box">7.2.1</a> for the
	      box(es) of the element in that line box (in tree order).
	    </ol>
	</ol>

      <li>
	Otherwise: first for the element, then for all its in-flow,
	non-positioned, block-level descendants in tree order:
	<ol>
	  <li>
	    If the element is a block-level replaced element, then:
	    the replaced content, atomically.

	  <li>
	    Otherwise, for each line box of that element:
	    <ol>
	      <li id="each-box">
		For each box that is a child of that element, in
		that line box, in tree order:
		<ol>
		  <li>
		    background color of element.
		  <li>
		    background image of element.
		  <li>
		    border of element.
		  <li>
		    For inline elements:
		    <ol>
		      <li>
			For all the element's in-flow,
			non-positioned, inline-level children that are
			in this line box, and all runs of text inside
			the element that is on this line box, in tree
			order:
			<ol>
			  <li>
			    If this is a run of text, then:
			    <ol>
			      <li>any underlining affecting the text
			      of the element, in tree order of the
			      elements applying the underlining (such
			      that the deepest element's underlining,
			      if any, is painted topmost and the root
			      element's underlining, if any, is drawn
			      bottommost).

			      <li>any overlining affecting the text of
			      the element, in tree order of the
			      elements applying the overlining (such
			      that the deepest element's overlining,
			      if any, is painted topmost and the root
			      element's overlining, if any, is drawn
			      bottommost).

			      <li>the text.

			      <li>any line-through affecting the text
			      of the element, in tree order of the
			      elements applying the line-through (such
			      that the deepest element's line-through,
			      if any, is painted topmost and the root
			      element's line-through, if any, is drawn
			      bottommost).
			    </ol>

			  <li>
			    Otherwise, jump to <a href="#each-box">7.2.1</a> for that
			    element.
			</ol>
		    </ol>

		    For inline-block and inline-table elements:
		    <ol>
		      <li>For each one of these, treat the element as
		      if it created a new stacking context, but any
		      positioned descendants and descendants which
		      actually create a new stacking context should be
		      considered part of the parent stacking context,
		      not this new one.
		    </ol>

		    For inline-level replaced elements:
		    <ol>
		      <li>the replaced content, atomically.
		    </ol>
		</ol>

		<p class="note">Some of the boxes may have been
		generated by line splitting or the Unicode
		bidirectional algorithm.

	      <li>
		Optionally, the outline of the element (see <a href="#outlines">10 below</a>).
	    </ol>

	  <li>
	    Optionally, if the element is block-level, the outline
	    of the element (see <a href="#outlines">10 below</a>).
	</ol>

      <li>
	All positioned descendants with 'z-index: auto' or
	'z-index: 0', in tree order. For those with 'z-index: auto',
	treat the element as if it created a new stacking context, but
	any positioned descendants and descendants which actually
	create a new stacking context should be considered part of the
	parent stacking context, not this new one. For those with
	'z-index: 0', treat the stacking context generated atomically.

      <li>
	Stacking contexts formed by positioned descendants with
	z-indices greater than or equal to 1 in z-index order
	(smallest first) then tree order.

      <li id="outlines">
	Finally, implementations that do not draw outlines in steps
	above must draw outlines from this stacking context at this
	stage. (It is recommended to draw outlines in this step and
	not in the steps above.)
    </ol>

    <h3 id="stacking-notes">Notes</h3>

    The background of the root element is only painted once, over
    the whole canvas.

    While the backgrounds of bidirectional inlines are painted in
    tree order, they are positioned in visual order. Since the
    positioning of inline backgrounds is unspecified in CSS&nbsp;2,
    the exact result of these two requirements is UA-defined. CSS3 may
    define this in more detail.


