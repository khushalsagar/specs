<pre class='metadata'>
Title: CSS Anchor Positioning
Shortname: css-anchor-position
Level: 1
Status: w3c/UD
Group: csswg
Work Status: exploring
URL: http://tabatkins.github.io/specs/css-anchor-position
Editor: Tab Atkins-Bittner, Google, http://xanthir.com/contact/, w3cid 42199
Abstract: This specification defines 'anchor positioning', where a positioned element can size and position itself relative to one or more "anchor elements" elsewhere on the page.
</pre>

Introduction {#intro}
=====================

Introduction here.

<pre class=propdef>
Name: anchor-name
Value: none | <<dashed-ident>>
Initial: none
Inherited: no
Animation Type: discrete
</pre>

If 'anchor-name' is not ''anchor-name/none'',
the element is an <dfn local-lt="anchor">anchor element</dfn>,
with an <dfn>anchor name</dfn> equal to the <<dashed-ident>>.

------

An [=absolutely-positioned=] element
can use the <dfn>anchor()</dfn> function
to refer to the position of one or more [=anchor elements=]
when setting its [=inset properties=].
The ''anchor()'' function resolves to a <<length>>.

<pre class=prod>
anchor() = anchor( <<dashed-ident>> <<anchor-side>>, <<length-percentage>>? )
<dfn><<anchor-side>></dfn> = top | left | right | bottom
              | start | end | self-start | self-end
              | <<percentage>> | center
</pre>

The ''anchor()'' function has three arguments:

* the <<dashed-ident>> specifies the [=anchor name=] of the [=anchor element=]
	it will be drawing positioning information from.

	Issue: Do we need the ability to refer to multiple anchors?
	Like, leftmost among all with a given name,
	or leftmost between two given names?
	Think about if it's possible to do google-docs style comments
	with minimal or zero scripting.

* the <<anchor-side>> value
	refers to the position of the corresponding side
	of the [=target anchor element=].

	The physical <<anchor-side>> keywords
	(<dfn value for=anchor()>left</dfn>,
	<dfn value for=anchor()>right</dfn>,
	<dfn value for=anchor()>top</dfn>,
	and <dfn value for=anchor()>bottom</dfn>)
	must only be used in [=inset properties=]
	corresponding to the same axis:
	for example, ''top'' and ''bottom'' are valid in 'top' and 'bottom',
	but not in 'left' and 'right'.
	Using wrong-axis keywords makes the function invalid.

	The logical <<anchor-side>> keywords
	(<dfn value for=anchor()>start</dfn>,
	<dfn value for=anchor()>end</dfn>,
	<dfn value for=anchor()>self-start</dfn>,
	and <dfn value for=anchor()>self-end</dfn>)
	map to one of the physical keywords
	depending on the property the function is being used in
	(''top'' or ''bottom'' in the 'top' or 'bottom' properties, etc)
	and the [=writing mode=] of either the element
	(for ''self-start'' and ''self-end'')
	or the [=writing mode=] of the element's [=containing block=]
	(for ''start'' and ''end'').

	Issue: Do we need to refer to the anchor element's [=writing mode=]?
	I think that's too unpredictable to actually do anything useful.

	A <<percentage>> value refers to a position
	a corresponding percentage between the ''start'' and ''end'' sides,
	with ''0%'' being equivalent to ''start''
	and ''100%'' being equivalent to ''end''.
	The <dfn value for=anchor()>center</dfn> keyword is equivalent to ''50%''.

* the optional <<length-percentage>> final argument is a fallback value.
	If the ''anchor()'' represents an [=invalid anchor query=],
	it resolves to this value
	rather that determining its value as detailed below.

	If omitted,
	it defaults to ''0px''.

An ''anchor()'' function representing a [=valid anchor query=]
resolves to the <<length>>
that would align the edge
of the positioned elements' [=inset-modified containing block=]
corresponding to the property the function appears in
with the specified border edge of the [=target anchor element=].

Issue: Do we need to control which box we're referring to,
so you can align to padding or content edge?

For this purpose, all scrolling containers
are treated as if scrolled to their initial scroll position,
and all transforms are ignored.

<div class=example>
	For example,
	in ''.bar { top: anchor(--foo, top); }'',
	the ''anchor()'' will resolve to the length
	that'll line up the <code>.bar</code> element's top edge
	with the ''--foo'' anchor's top edge.

	On the other hand,
	in ''.bar { bottom: anchor(--foo, top); }'',
	it will instead resolve to the length
	that'll line up the <code>.bar</code> element's <em>bottom</em> edge
	with the ''--foo'' anchor's top edge.

	Since 'top' and 'bottom' values specify insets from different edges
	(the top and bottom of the element's [=containing block=],
	respectively),
	the same ''anchor()'' will usually resolve to different lengths in each.
</div>

<hr>

An [=absolutely-positioned=] element
can use the <dfn>anchor-size()</dfn> function
to refer to the size of one or more [=anchor elements=].
Unlike ''anchor()'', ''anchor-size()'' is not restricted to certain properties.
The ''anchor-size()'' function resolves to a <<length>>.

<pre class=prod>
anchor-size() = anchor( <<dashed-ident>> <<anchor-size>>, <<length-percentage>>? )
<dfn><<anchor-size>></dfn> = width | height | block | inline | self-block | self-inline
</pre>

The ''anchor-size()'' function is similar to ''anchor()'',
and takes the same arguments,
save that the <<anchor-side>> keywords are replaced with <<anchor-size>>,
referring to the distance between two opposing sides.

The physical <<anchor-size>> keywords
(<dfn value for=anchor-size()>width</dfn>
and <dfn value for=anchor-size()>height</dfn>)
refer to the width and height,
respectively,
of the [=target anchor element=].
Unlike ''anchor()'', there is no restriction on having to match axises;
for example, ''width: anchor-size(--foo height);'' is valid.

The logical <<anchor-size>> keywords
(<dfn value for=anchor-size()>block</dfn>,
<dfn value for=anchor-size()>inline</dfn>,
<dfn value for=anchor-size()>self-block</dfn>,
and <dfn value for=anchor-size()>self-inline</dfn>)
map to one of the physical keywords
according to either the [=writing mode=] of the element
(for ''self-block'' and ''self-inline'')
or the [=writing mode=] of the element's [=containing block=]
(for ''block'' and ''inline'').

An ''anchor-size()'' function representing a [=valid anchor query=]
resolves to the <<length>> separating the relevant border edges
(either left and right, or top and bottom,
whichever is in the specified axis)
of the [=target anchor element=].

## Determining The Anchor

The ''anchor()'' and ''anchor-size()'' functions
specify an [=anchor element=] by name.
That name is not necessarily unique on the page, however.
To determine the <dfn>target [=anchor element=]</dfn>,
find the first element in tree order
which satisfies the following conditions:

* is an [=anchor element=] with the given [=anchor name=]
* is a descendant of the querying element's [=containing block=],
	or the quering element's [=containing block=] is the [=initial containing block=]
* if it has the same [=containing block=] as the querying element,
	it is not itself [=positioned=]
* if it has a different [=containing block=] from the querying element,
	the last [=containing block=] in its [=containing block chain=]
	before reaching the querying element's [=containing block=]
	is not, itself, [=positioned=]

Note: There might not be any such element.

Note: These conditions ensure that the [=anchor element=]
is laid out strictly before the element using ''anchor()'' or ''anchor-size()'',
so there is no possible circularity between the position and/or size
of the two elements.


## Anchor Queries

The ''anchor()'' and ''anchor-size()'' functions
represent an <dfn>anchor query</dfn>:
a request for the position of one or more sides
of one or more [=anchor elements=].

[=Anchor queries=] are <dfn lt="valid anchor query|invalid anchor query" local-lt="invalid|valid">valid</dfn>
only if all of the following conditions are true:

* Their function is used on an element that is [=absolutely-positioned=].
* The ''anchor()'' function is used in an [=inset property=].
* There is a [=target anchor element=].

Note: As specified in the definition of ''anchor()'',
an [=invalid anchor query=]
causes the function to resolve to its fallback value instead.

Position Fallback
=================

Anchor positioning,
while powerful,
can also be unpredictable.
The [=anchor element=] might be anywhere on the page,
so positioning an element in any particular fashion
(such as above the anchor, or the right of the anchor)
might result in the positioned element overflowing
or being positioned partially off screen.

''@position-set'' allows an author to specify multiple sets of properties,
and try each set on the element one by one,
selecting the first that results in the positioned element
not overflowing its containing block.


Issue: Fill in the @position-set stuff from <a href="https://github.com/MicrosoftEdge/MSEdgeExplainers/blob/main/CSSAnchoredPositioning/explainer.md">the MS Edge explainer</a>.

Sketch:

<pre highlight=css>
@position-set --foo {
	@try {
		top: ...;
		width: ...;
	}
	@try {
		other stuff
	}
}

.foo {
	position: fixed;
	position-set: --foo;
}
</pre>

* tries out each @try, in order, applying the properties specified in it
	(treated as having the same cascade info as the style rule with 'position-set',
	but a source position immediately following the style rule)
* a @try is discarded if it results in the element overflowing its [=inset-modified containing block=]
* If all @trys are discarded, stick with the last one
	(it's usually going to be the "largest", most general size/position,
	and thus the least bad in emergency situations)
* Because evaluating @trys is expensive, especially when nested,
	UAs can have impl-defined limits on how many attempts they do.
	A top-level positioned element
	(that is, an element using 'position-set'
	with no ancestor doing the same)
	must support at least five @trys
	(enough to try a position on all four sides, then a final fallback),
	but non-top-level have no required minimum.

Names 100% tbd